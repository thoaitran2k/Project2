import { createSlice, createAsyncThunk, current } from "@reduxjs/toolkit";
import axios from "axios";
import { updateAddress } from "../../Services/UserService";

// ‚úÖ L·∫•y user t·ª´ localStorage n·∫øu c√≥
const getUserFromLocalStorage = () => {
  const storedUser = localStorage.getItem("user");
  return storedUser ? JSON.parse(storedUser) : null;
};

export const updateAddressList = createAsyncThunk(
  "user/updateAddressList",
  async (_, { getState }) => {
    const userState = getState().user;
    const accessToken = userState?.accessToken;

    if (!accessToken) throw new Error("Kh√¥ng c√≥ accessToken!");

    const response = await axios.get(
      `http://localhost:3002/api/user/${userState._id}/addresses`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );

    return response.data; // Danh s√°ch ƒë·ªãa ch·ªâ m·ªõi t·ª´ API
  }
);

export const updateUserAddress = createAsyncThunk(
  "user/updateUserAddress",
  async ({ userId, addressId, newAddress }, { getState, dispatch }) => {
    const accessToken = getState().user.accessToken;

    if (!accessToken) throw new Error("Kh√¥ng c√≥ accessToken!");

    // G·ªçi API ƒë·ªÉ c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ
    const updatedAddress = await updateAddress(
      userId,
      addressId,
      newAddress,
      accessToken
    );

    await dispatch(updateAddressList());
    // Tr·∫£ v·ªÅ d·ªØ li·ªáu ƒë·ªãa ch·ªâ ƒë√£ c·∫≠p nh·∫≠t
    return updatedAddress;
  }
);

// ‚úÖ Async action ƒë·ªÉ c·∫≠p nh·∫≠t user profile
export const updateUserProfile = createAsyncThunk(
  "user/updateUserProfile",
  async (updatedData, { getState }) => {
    const userState = getState().user; // Tr√°nh l·∫•y sai ƒë∆∞·ªùng d·∫´n
    const accessToken = userState?.accessToken;

    if (!accessToken) throw new Error("Kh√¥ng c√≥ accessToken!");

    const response = await axios.put(
      "http://localhost:3002/api/user/update-profile",
      updatedData,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );
    return response.data;
  }
);

const initialState = getUserFromLocalStorage() || {
  isAuthenticated: false,
  _id: null,
  accessToken: null,
  refreshToken: null,
  username: null,
  email: null,
  phone: null,
  address: [],
  avatar: null,
  dob: null,
  gender: null,
  isLoggingOut: false,
  isAdmin: false,
  isBlocked: false,
};

const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    setUser: (state, action) => {
      const userData = action.payload;

      if (!userData) {
        console.error("Payload kh√¥ng h·ª£p l·ªá!");
        return;
      }
      state.address = Array.isArray(userData.address)
        ? userData.address
        : state.address;

      state.isAuthenticated = true;
      state._id = userData._id;
      state.username = userData.username;
      state.email = userData.email;
      state.phone = userData.phone;
      //state.address = userData.address || [];
      state.avatar = userData.avatar || "";
      state.dob = userData.dob;
      state.gender = userData.gender;

      state.isAdmin =
        userData.isAdmin !== undefined ? userData.isAdmin : state.isAdmin;
      state.isBlocked = userData.isBlocked ?? false;
      state.createdAt = userData.createdAt;
      state.updatedAt = userData.updatedAt;

      if (userData.accessToken) state.accessToken = userData.accessToken;
      if (userData.refreshToken) state.refreshToken = userData.refreshToken;

      // L∆∞u v√†o localStorage
      // const pureState = current(state);
      // console.log("D·ªØ li·ªáu state:", pureState);

      // console.log(
      //   "D·ªØ li·ªáu state sau khi c·∫≠p nh·∫≠t:",
      //   JSON.parse(JSON.stringify(state))
      // );
      // L∆∞u v√†o localStorage
      localStorage.setItem("user", JSON.stringify(state));
    },
    removeUserAddress: (state, action) => {
      const addressId = action.payload;
      // Lo·∫°i b·ªè ƒë·ªãa ch·ªâ c√≥ id tr√πng v·ªõi addressId
      state.address = state.address.filter(
        (addr) => addr._id !== action.payload
      );
      localStorage.setItem("user", JSON.stringify(state)); // L∆∞u l·∫°i v√†o localStorage
    },
    updateAddresses: (state, action) => {
      const updatedAddress = action.payload;
      const index = state.address.findIndex(
        (addr) => addr._id === updatedAddress._id
      );
      if (index !== -1) {
        state.address[index] = updatedAddress;
        localStorage.setItem("user", JSON.stringify(state));
      } else {
        console.error("ƒê·ªãa ch·ªâ kh√¥ng t·ªìn t·∫°i!");
      }
    },
    setUserAddresses: (state, action) => {
      if (!action.payload || !Array.isArray(action.payload)) {
        console.error("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá!", action.payload);
        return;
      }
      const flattenedAddresses = action.payload.flat();

      const uniqueAddresses = Array.from(
        new Map(flattenedAddresses.map((addr) => [addr._id, addr])).values()
      );

      state.address = uniqueAddresses;
      localStorage.setItem("user", JSON.stringify(state));
    },

    setDefaultAddress: (state, action) => {
      const addressId = action.payload;
      state.address.forEach((addr) => {
        addr.isDefault = addr._id === addressId;
      });
      localStorage.setItem("user", JSON.stringify(state));
    },
    removeAddress: (state, action) => {
      const addressId = action.payload;
      state.address = state.address.filter((addr) => addr._id !== addressId);
      localStorage.setItem("user", JSON.stringify(state));
    },

    updateUserField: (state, action) => {
      const { field, value } = action.payload;
      if (field in state) {
        state[field] = value;
        localStorage.setItem("user", JSON.stringify(state));
      } else {
        console.error(`Tr∆∞·ªùng ${field} kh√¥ng t·ªìn t·∫°i trong state!`);
      }
    },

    logoutUser: (state) => {
      localStorage.removeItem("user"); // ‚úÖ X√≥a user kh·ªèi localStorage khi logout
      Object.assign(state, {
        ...initialState,
        isAuthenticated: false,
        //isAdmin: true,
      });
    },

    setLoggingOut: (state, action) => {
      state.isLoggingOut = action.payload;
    },

    addUserAddress: (state, action) => {
      const newAddresses = action.payload; // M·∫£ng ƒë·ªãa ch·ªâ m·ªõi t·ª´ API

      if (!Array.isArray(newAddresses)) return;

      // Kh·ªüi t·∫°o state.address n·∫øu ch∆∞a c√≥
      if (!state.address) state.address = [];

      // N·∫øu c√≥ ƒë·ªãa ch·ªâ m·ªõi l√† m·∫∑c ƒë·ªãnh, ƒë·∫∑t l·∫°i isDefault c·ªßa ƒë·ªãa ch·ªâ c≈©
      const hasNewDefault = newAddresses.some((addr) => addr.isDefault);

      if (hasNewDefault) {
        state.address = state.address.map((addr) => ({
          ...addr,
          isDefault: false, // ƒê·∫∑t t·∫•t c·∫£ ƒë·ªãa ch·ªâ c≈© v·ªÅ kh√¥ng m·∫∑c ƒë·ªãnh
        }));
      }

      // Th√™m ho·∫∑c c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ m·ªõi v√†o Redux store
      newAddresses.forEach((newAddress) => {
        const index = state.address.findIndex(
          (addr) => addr._id === newAddress._id
        );
        if (index !== -1) {
          // N·∫øu ƒë·ªãa ch·ªâ ƒë√£ t·ªìn t·∫°i, c·∫≠p nh·∫≠t th√¥ng tin
          state.address[index] = newAddress;
        } else {
          // N·∫øu ch∆∞a c√≥, th√™m v√†o danh s√°ch
          state.address.push(newAddress);
        }
      });

      // L∆∞u v√†o localStorage
      localStorage.setItem("userAddresses", JSON.stringify(state.address));
      console.log("‚úÖ ƒê√£ c·∫≠p nh·∫≠t danh s√°ch ƒë·ªãa ch·ªâ v√†o Redux:", state.address);
    },
  },

  extraReducers: (builder) => {
    builder
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        const {
          username,
          email,
          phone,
          dob,
          gender,
          address,
          avatar,
          isAdmin,
        } = action.payload;
        state.username = username;
        state.email = email;
        state.phone = phone;
        state.dob = dob;
        state.gender = gender;
        state.address = address;
        state.avatar = avatar;
        state.isAdmin = isAdmin;
        localStorage.setItem("user", JSON.stringify(state));
      })
      // .addCase(deleteAddress.fulfilled, (state, action) => {
      //   const addressId = action.payload._id; // Gi·∫£ s·ª≠ API tr·∫£ v·ªÅ d·ªØ li·ªáu ƒë·ªãa ch·ªâ ƒë√£ x√≥a
      //   state.address = state.address.filter((addr) => addr._id !== addressId);
      //   localStorage.setItem("user", JSON.stringify(state)); // L∆∞u l·∫°i v√†o localStorage
      // })
      .addCase(updateAddressList.fulfilled, (state, action) => {
        console.log("üöÄ API tr·∫£ v·ªÅ danh s√°ch ƒë·ªãa ch·ªâ m·ªõi:", action.payload);

        if (!action.payload || !Array.isArray(action.payload.data)) {
          console.error(
            "‚ùå D·ªØ li·ªáu t·ª´ API kh√¥ng ph·∫£i l√† m·∫£ng!",
            action.payload
          );
          return;
        }

        // ‚ùå C√≥ th·ªÉ m·∫£ng ƒë√£ ph·∫≥ng nh∆∞ng b·∫°n l·∫°i ti·∫øp t·ª•c `.flat()`
        console.log("üìå API tr·∫£ v·ªÅ:", action.payload.data);
        const flattenedAddresses = Array.isArray(action.payload.data[0])
          ? action.payload.data.flat()
          : action.payload.data;
        console.log("üìå Sau khi l√†m ph·∫≥ng:", flattenedAddresses);

        // Lo·∫°i b·ªè ƒë·ªãa ch·ªâ tr√πng l·∫∑p d·ª±a tr√™n `_id`
        const uniqueAddresses = Array.from(
          new Map(flattenedAddresses.map((addr) => [addr._id, addr])).values()
        );

        // ‚úÖ C·∫≠p nh·∫≠t state ƒë√∫ng c√°ch
        state.address = uniqueAddresses;
        localStorage.setItem("user", JSON.stringify(state));
      })
      .addCase(updateUserAddress.fulfilled, (state, action) => {
        const newAddress = action.payload;
        if (!newAddress || typeof newAddress !== "object") return;

        if (!action.payload || !action.payload.data) {
          console.error("‚ùå API kh√¥ng tr·∫£ v·ªÅ d·ªØ li·ªáu h·ª£p l·ªá!", action.payload);
          return;
        }

        let updatedAddress = action.payload.data.address;

        // Ki·ªÉm tra n·∫øu updatedAddress l√† m·∫£ng, ch·ªâ l·∫•y ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n
        updatedAddress = Array.isArray(updatedAddress)
          ? updatedAddress[0]
          : updatedAddress;

        //console.log("üîπ ƒê·ªãa ch·ªâ ƒë√£ c·∫≠p nh·∫≠t:", updatedAddress);

        const index = state.address.findIndex(
          (addr) => addr._id === updatedAddress._id
        );
        if (index !== -1) {
          state.address[index] = updatedAddress;
        } else {
          console.warn(
            "üö® ƒê·ªãa ch·ªâ kh√¥ng t·ªìn t·∫°i trong Redux! Th√™m v√†o danh s√°ch..."
          );
          state.address.push(updatedAddress);
        }

        // L∆∞u l·∫°i v√†o localStorage
        localStorage.setItem("user", JSON.stringify(state));
      });
  },
});

export const {
  setUser,
  logoutUser,
  setLoggingOut,
  updateUserField,
  setDefaultAddress,
  addUserAddress,
  deleteAddress,
  removeAddress,
  updateAddresses,
  setUserAddresses,
  removeUserAddress,
} = userSlice.actions;
export default userSlice.reducer;
